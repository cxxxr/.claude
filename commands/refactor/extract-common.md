---
description: 重複コードを検出し共通コンポーネントとして抽出
argument-hint: "[path]"
---

指定されたパス（デフォルト: プロジェクト全体）で重複コードを検出し、適切な共通コンポーネントとして抽出してください。

**重要**: 偶然の一致を一般化しないこと。正しい境界の発見が目的であり、単なる重複削減ではない。

## 偶発的同型フィルター (Abstraction Gate)

各重複候補に対し、以下の10項目をYes/Noで評価し表形式で提示:

| # | 評価項目 | 判定 | 根拠（コード引用） |
|---|---------|------|------------------|
| 1 | **同一ドメイン概念**: 両方を同じドメイン用語で命名できるか |  |  |
| 2 | **同一入出力契約**: 型・事前条件・事後条件・不変条件が一致するか |  |  |
| 3 | **同一失敗セマンティクス**: 例外・エラー・境界ケースの扱いが同じか |  |  |
| 4 | **同一副作用境界**: I/O・DB・キャッシュ・トランザクション境界・スレッド安全性が同一か |  |  |
| 5 | **同一依存レイヤー**: 同じ層（UI/ドメイン/インフラ）に属するか。層跨ぎは不可 |  |  |
| 6 | **同一変更理由 (SRP)**: 将来、同じ理由で一緒に変更されるか |  |  |
| 7 | **同一パフォーマンス制約**: 計算量・レイテンシ・メモリ・リアルタイム要件が共通か |  |  |
| 8 | **テスト統合可能性**: 単一のパラメータ化テストで同一合格基準でカバーできるか |  |  |
| 9 | **呼び出し側の簡素化**: 抽象化後、呼び出し側の分岐・変換が減るか。増えるならNo |  |  |
| 10 | **命名テスト**: 具体的で意味のある名前を付けられるか（util/common/miscは不可） |  |  |

### スコア判定

- **8/10以上 Yes** → 一般化を実施
- **5〜7 Yes** → 最小限の抽出（薄いヘルパーまたはインターフェース）
- **4以下 Yes** → 一般化しない

## 安全弁ルール

以下に該当する場合は抽出を中止:

| ルール | 条件 |
|--------|------|
| **3回ルール** | 呼び出し箇所が2箇所のみなら抽出を保留。3箇所以上で優先的に抽出 |
| **フラグ引数禁止** | 動作切替フラグ（bool isXxx等）が2つ以上必要なら中止 |
| **分岐集中禁止** | 差異を吸収するためだけにswitch/ifが増えるなら中止 |
| **データ変換オーバーヘッド** | 一般化のためだけに呼び出し側でアダプタ/変換が3ステップ以上増えるなら中止 |

## 出力フォーマット

各候補について以下を提示:

### 1. 評価テーブル
偶発的同型フィルター表（10項目）と合計スコア

### 2. 抽象化の定義
- 採用する抽象化の名前
- 公開API（シグネチャ）
- 最小責任の1〜2文説明

### 3. 呼び出し側の変更
擬似diffで変更前後を示し、複雑性削減の根拠を説明

### 4. テスト計画
- 統合テスト: 一般化されたコード用
- 残存テスト: 一般化しなかったコードの正当性確認

### 5. リスクと撤退計画
- 想定される失敗パターン
- 安全にロールバックする方法

## 不確実性の扱い

- 評価項目が「不明」の場合はNoとして扱う（不確実なら一般化を避ける）
- 評価が割れる場合は最小限の抽出を選択

## 手順

1. 対象パスのコードを分析し、重複候補をリストアップ
2. 各候補に偶発的同型フィルターを適用
3. スコアと安全弁ルールに基づき抽出可否を判定
4. 抽出対象について上記フォーマットで計画を提示
5. ユーザーの承認後、リファクタリングを実施
6. テストが通ることを確認

対象パス: $ARGUMENTS
